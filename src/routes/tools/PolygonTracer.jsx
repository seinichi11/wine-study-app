// src/routes/tools/PolygonTracer.jsx
import { useEffect, useMemo, useRef, useState } from "react";

const VB = { w: 700, h: 620 };

const DEFAULT_NAMES = [
  "Médoc",
  "Haut-Médoc",
  "Saint-Estèphe",
  "Pauillac",
  "Saint-Julien",
  "Margaux",
  "Moulis",
  "Listrac",
  "Graves",
  "Pessac-Léognan",
];
const DEFAULT_RIVERS = [
  {
    name: "Gironde",
    points: [],
    stroke: "#9acbff",
    width: 16,
    opacity: 0.95,
    smooth: true,
    tension: 0.5,
  },
  {
    name: "Garonne",
    points: [],
    stroke: "#9acbff",
    width: 14,
    opacity: 0.95,
    smooth: true,
    tension: 0.5,
  },
  {
    name: "Dordogne",
    points: [],
    stroke: "#9acbff",
    width: 14,
    opacity: 0.95,
    smooth: true,
    tension: 0.5,
  },
];
const DEFAULT_CITIES = [];

function toPolyString(points) {
  return points.map(([x, y]) => `${Math.round(x)},${Math.round(y)}`).join(" ");
}
function catmullRomToBezierPath(pts, tension = 0.5) {
  if (!pts || pts.length < 2) return "";
  const p = pts.map(([x, y]) => ({ x, y }));
  let d = `M ${Math.round(p[0].x)},${Math.round(p[0].y)}`;
  for (let i = 0; i < p.length - 1; i++) {
    const p0 = i === 0 ? p[0] : p[i - 1];
    const p1 = p[i];
    const p2 = p[i + 1];
    const p3 = i + 2 < p.length ? p[i + 2] : p[i + 1];
    const t = (1 - tension) / 6;
    const c1x = p1.x + (p2.x - p0.x) * t;
    const c1y = p1.y + (p2.y - p0.y) * t;
    const c2x = p2.x - (p3.x - p1.x) * t;
    const c2y = p2.y - (p3.y - p1.y) * t;
    d += ` C ${Math.round(c1x)},${Math.round(c1y)} ${Math.round(c2x)},${Math.round(c2y)} ${Math.round(p2.x)},${Math.round(p2.y)}`;
  }
  return d;
}

function textRegionsJS(regions) {
  const body = regions
    .filter((r) => r.name.trim() && r.points.length >= 3)
    .map(
      (r) =>
        `  "${r.name}": {\n    polygon: "${toPolyString(r.points)}",\n    info: ""\n  }`
    )
    .join(",\n");
  return `// auto-generated by PolygonTracer (regions)
export const V = "bordeaux-polys traced";

const regions = {
${body}
};

export default regions;
`;
}
function textRiversJS(rivers) {
  const body = rivers
    .filter((r) => r.name.trim() && r.points.length >= 2)
    .map((r) => {
      const d = r.smooth
        ? catmullRomToBezierPath(r.points, r.tension ?? 0.5)
        : "";
      return `  { name: "${r.name}", points: "${toPolyString(r.points)}", d: "${d}", smooth: ${!!r.smooth}, tension: ${r.tension ?? 0.5}, stroke: "${r.stroke}", width: ${r.width}, opacity: ${r.opacity} }`;
    })
    .join(",\n");
  return `// auto-generated by PolygonTracer (rivers)
export const V_RIVERS = "bordeaux-rivers traced";

const rivers = [
${body}
];

export default rivers;
`;
}
function textCitiesJS(cities) {
  const body = cities
    .filter((c) => c.name.trim())
    .map(
      (c) =>
        `  { name: "${c.name}", x: ${Math.round(c.x)}, y: ${Math.round(c.y)}, color: "${c.color}", size: ${c.size} }`
    )
    .join(",\n");
  return `// auto-generated by PolygonTracer (cities)
export const V_CITIES = "bordeaux-cities traced";

const cities = [
${body}
];

export default cities;
`;
}

async function saveWithPicker(filename, content, typeDesc = "JavaScript") {
  if (window.showSaveFilePicker) {
    const handle = await window.showSaveFilePicker({
      suggestedName: filename,
      types: [
        {
          description: typeDesc,
          accept: { "application/javascript": [".js"] },
        },
      ],
    });
    const writable = await handle.createWritable();
    await writable.write(content);
    await writable.close();
    return true;
  }
  return false;
}
function fallbackDownload(filename, content) {
  const blob = new Blob([content], { type: "text/javascript;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

export default function PolygonTracer() {
  const svgRef = useRef(null);
  const [imgUrl, setImgUrl] = useState("/bordeaux_ref.png");
  const [imgOpacity, setImgOpacity] = useState(88);
  const [zoom, setZoom] = useState(100);
  const [showGrid, setShowGrid] = useState(false);
  const [mode, setMode] = useState("regions");
  const [regions, setRegions] = useState(() =>
    DEFAULT_NAMES.map((name) => ({ name, points: [] }))
  );
  const [activeRegionIdx, setActiveRegionIdx] = useState(0);
  const [rivers, setRivers] = useState(() => DEFAULT_RIVERS);
  const [activeRiverIdx, setActiveRiverIdx] = useState(0);
  const [cities, setCities] = useState(() => DEFAULT_CITIES);
  const [activeCityIdx, setActiveCityIdx] = useState(0);
  const [dragIdx, setDragIdx] = useState(null);

  function addPoint(e) {
    const svg = svgRef.current;
    if (!svg) return;
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const { x, y } = pt.matrixTransform(svg.getScreenCTM().inverse());
    const nx = Math.max(0, Math.min(VB.w, x));
    const ny = Math.max(0, Math.min(VB.h, y));

    if (mode === "regions") {
      setRegions((prev) => {
        const next = [...prev];
        next[activeRegionIdx] = {
          ...next[activeRegionIdx],
          points: [...next[activeRegionIdx].points, [nx, ny]],
        };
        return next;
      });
    } else if (mode === "rivers") {
      setRivers((prev) => {
        const next = [...prev];
        next[activeRiverIdx] = {
          ...next[activeRiverIdx],
          points: [...next[activeRiverIdx].points, [nx, ny]],
        };
        return next;
      });
    } else {
      setCities((prev) => [
        ...prev,
        {
          name: `City ${prev.length + 1}`,
          x: nx,
          y: ny,
          color: "#111827",
          size: 6,
        },
      ]);
      setActiveCityIdx(cities.length);
      setDragIdx(null);
    }
  }

  function onHandleDown(idx, e) {
    e.stopPropagation();
    setDragIdx(idx);
  }
  function onMouseMove(e) {
    if (dragIdx == null) return;
    const svg = svgRef.current;
    if (!svg) return;
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const { x, y } = pt.matrixTransform(svg.getScreenCTM().inverse());
    const nx = Math.max(0, Math.min(VB.w, x));
    const ny = Math.max(0, Math.min(VB.h, y));

    if (mode === "regions") {
      setRegions((prev) => {
        const next = [...prev];
        const pts = next[activeRegionIdx].points.slice();
        pts[dragIdx] = [nx, ny];
        next[activeRegionIdx] = { ...next[activeRegionIdx], points: pts };
        return next;
      });
    } else if (mode === "rivers") {
      setRivers((prev) => {
        const next = [...prev];
        const pts = next[activeRiverIdx].points.slice();
        pts[dragIdx] = [nx, ny];
        next[activeRiverIdx] = { ...next[activeRiverIdx], points: pts };
        return next;
      });
    } else {
      setCities((prev) =>
        prev.map((c, i) => (i === activeCityIdx ? { ...c, x: nx, y: ny } : c))
      );
    }
  }
  function onMouseUp() {
    setDragIdx(null);
  }

  function undoPoint() {
    if (mode === "regions") {
      setRegions((prev) => {
        const next = [...prev];
        next[activeRegionIdx] = {
          ...next[activeRegionIdx],
          points: next[activeRegionIdx].points.slice(0, -1),
        };
        return next;
      });
    } else if (mode === "rivers") {
      setRivers((prev) => {
        const next = [...prev];
        next[activeRiverIdx] = {
          ...next[activeRiverIdx],
          points: next[activeRiverIdx].points.slice(0, -1),
        };
        return next;
      });
    } else if (mode === "cities") {
      setCities((prev) => prev.slice(0, -1));
      setActiveCityIdx((i) => Math.max(0, i - 1));
    }
  }
  function clearCurrent() {
    if (mode === "regions") {
      setRegions((prev) => {
        const n = [...prev];
        n[activeRegionIdx] = { ...n[activeRegionIdx], points: [] };
        return n;
      });
    } else if (mode === "rivers") {
      setRivers((prev) => {
        const n = [...prev];
        n[activeRiverIdx] = { ...n[activeRiverIdx], points: [] };
        return n;
      });
    } else {
      setCities([]);
      setActiveCityIdx(0);
    }
  }
  function addItem() {
    if (mode === "regions") {
      setRegions((prev) => [
        ...prev,
        { name: `Area ${prev.length + 1}`, points: [] },
      ]);
      setActiveRegionIdx(regions.length);
    } else if (mode === "rivers") {
      setRivers((prev) => [
        ...prev,
        {
          name: `River ${prev.length + 1}`,
          points: [],
          stroke: "#9acbff",
          width: 12,
          opacity: 0.95,
          smooth: true,
          tension: 0.5,
        },
      ]);
      setActiveRiverIdx(rivers.length);
    } else {
      setCities((prev) => [
        ...prev,
        {
          name: `City ${prev.length + 1}`,
          x: VB.w / 2,
          y: VB.h / 2,
          color: "#111827",
          size: 6,
        },
      ]);
      setActiveCityIdx(cities.length);
    }
  }
  function removeItem(idx) {
    if (!window.confirm("削除しますか？")) return;
    if (mode === "regions") {
      setRegions((prev) => prev.filter((_, i) => i !== idx));
      setActiveRegionIdx((a) => Math.max(0, a - (idx <= a ? 1 : 0)));
    } else if (mode === "rivers") {
      setRivers((prev) => prev.filter((_, i) => i !== idx));
      setActiveRiverIdx((a) => Math.max(0, a - (idx <= a ? 1 : 0)));
    } else {
      setCities((prev) => prev.filter((_, i) => i !== idx));
      setActiveCityIdx((a) => Math.max(0, a - (idx <= a ? 1 : 0)));
    }
  }

  /* --- Export --- */
  async function exportRegions() {
    const js = textRegionsJS(regions);
    try {
      (await saveWithPicker("bordeaux.js", js)) ||
        fallbackDownload("bordeaux.js", js);
    } catch {
      fallbackDownload("bordeaux.js", js);
    }
  }
  async function exportRivers() {
    const js = textRiversJS(rivers);
    try {
      (await saveWithPicker("bordeauxRivers.js", js)) ||
        fallbackDownload("bordeauxRivers.js", js);
    } catch {
      fallbackDownload("bordeauxRivers.js", js);
    }
  }
  async function exportCities() {
    const js = textCitiesJS(cities);
    try {
      (await saveWithPicker("bordeauxCities.js", js)) ||
        fallbackDownload("bordeauxCities.js", js);
    } catch {
      fallbackDownload("bordeauxCities.js", js);
    }
  }

  /* --- ショートカット --- */
  useEffect(() => {
    function onKey(e) {
      if (e.key === "Backspace") {
        e.preventDefault();
        undoPoint();
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "z") {
        e.preventDefault();
        undoPoint();
      }
      if ((e.metaKey || e.ctrlKey) && (e.key === "=" || e.key === "+")) {
        e.preventDefault();
        setZoom((z) => Math.min(300, z + 10));
      }
      if ((e.metaKey || e.ctrlKey) && e.key === "-") {
        e.preventDefault();
        setZoom((z) => Math.max(60, z - 10));
      }
      if ((e.metaKey || e.ctrlKey) && e.key === "0") {
        e.preventDefault();
        setZoom(100);
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [mode, activeRegionIdx, activeRiverIdx, activeCityIdx]);

  const grid = useMemo(() => {
    if (!showGrid) return null;
    const step = 50,
      lines = [];
    for (let x = step; x < VB.w; x += step)
      lines.push(
        <line
          key={`vx${x}`}
          x1={x}
          y1={0}
          x2={x}
          y2={VB.h}
          stroke="#e5e7eb"
          strokeWidth="1"
        />
      );
    for (let y = step; y < VB.h; y += step)
      lines.push(
        <line
          key={`hz${y}`}
          x1={0}
          y1={y}
          x2={VB.w}
          y2={y}
          stroke="#e5e7eb"
          strokeWidth="1"
        />
      );
    return <g>{lines}</g>;
  }, [showGrid]);

  return (
    <div style={{ maxWidth: 1200, margin: "0 auto", padding: 16 }}>
      <h1 style={{ fontWeight: 800, fontSize: 22, marginBottom: 10 }}>
        🖊️ Polygon / Polyline / Point Tracer（{VB.w}×{VB.h}）
      </h1>

      {/* ツールバー */}
      <div
        style={{
          display: "flex",
          gap: 12,
          alignItems: "center",
          flexWrap: "wrap",
          marginBottom: 12,
        }}
      >
        {/* モード切替 */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: 8,
            background: "#f9fafb",
            border: "1px solid #e5e7eb",
            borderRadius: 999,
            padding: 4,
          }}
        >
          {["regions", "rivers", "cities"].map((m) => (
            <button
              key={m}
              type="button"
              onClick={() => setMode(m)}
              style={{
                ...segBtn,
                background: mode === m ? "#111" : "transparent",
                color: mode === m ? "#fff" : "#111",
              }}
            >
              {m === "regions" ? "地域" : m === "rivers" ? "川" : "街"}
            </button>
          ))}
        </div>

        <label style={{ fontSize: 13 }}>
          参照画像：
          <input
            type="file"
            accept="image/*"
            onChange={(e) => {
              const f = e.target.files?.[0];
              if (f) setImgUrl(URL.createObjectURL(f));
            }}
          />
        </label>

        <button onClick={addItem} style={btn}>
          + 追加
        </button>
        <button onClick={clearCurrent} style={btn}>
          選択をクリア
        </button>
        <button onClick={undoPoint} style={btn}>
          1点戻る
        </button>

        <button onClick={exportRegions} style={btnStrong}>
          Export bordeaux.js（地域）
        </button>
        <button onClick={exportRivers} style={btnStrong}>
          Export bordeauxRivers.js（川）
        </button>
        <button onClick={exportCities} style={btnStrong}>
          Export bordeauxCities.js（街）
        </button>

        {/* ズーム・不透明度・グリッド */}
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <span style={{ fontSize: 12, color: "#666" }}>ズーム</span>
          <button
            type="button"
            style={miniBtn}
            onClick={() => setZoom((z) => Math.max(60, z - 10))}
          >
            −
          </button>
          <input
            type="range"
            min={60}
            max={300}
            value={zoom}
            onChange={(e) => setZoom(Number(e.target.value))}
            style={{ width: 160, accentColor: "#111" }}
          />
          <button
            type="button"
            style={miniBtn}
            onClick={() => setZoom((z) => Math.min(300, z + 10))}
          >
            ＋
          </button>
          <span style={{ fontSize: 12, width: 46, textAlign: "right" }}>
            {zoom}%
          </span>
          <button type="button" style={miniBtn} onClick={() => setZoom(100)}>
            リセット
          </button>
        </div>
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <span style={{ fontSize: 12, color: "#666" }}>画像の濃さ</span>
          <input
            type="range"
            min={0}
            max={100}
            value={imgOpacity}
            onChange={(e) => setImgOpacity(Number(e.target.value))}
            style={{ width: 140, accentColor: "#111" }}
          />
          <span style={{ fontSize: 12, width: 36, textAlign: "right" }}>
            {imgOpacity}%
          </span>
        </div>
        <label
          style={{
            display: "flex",
            alignItems: "center",
            gap: 6,
            fontSize: 12,
          }}
        >
          <input
            type="checkbox"
            checked={showGrid}
            onChange={(e) => setShowGrid(e.target.checked)}
          />
          グリッド表示
        </label>
      </div>

      {/* 左パネル + キャンバス */}
      <div style={{ display: "flex", gap: 12, alignItems: "stretch" }}>
        {/* 左：リスト */}
        <div
          style={{
            minWidth: 320,
            background: "#fff",
            border: "1px solid #eee",
            borderRadius: 10,
            padding: 10,
          }}
        >
          <div style={{ fontSize: 12, color: "#666", marginBottom: 6 }}>
            {mode === "regions" ? "地域" : mode === "rivers" ? "川" : "街"}
          </div>

          {mode === "regions" &&
            regions.map((r, i) => (
              <div key={i} style={row(i === activeRegionIdx)}>
                <input
                  value={r.name}
                  onChange={(e) =>
                    setRegions((prev) =>
                      prev.map((x, idx) =>
                        idx === i ? { ...x, name: e.target.value } : x
                      )
                    )
                  }
                  style={input}
                />
                <button onClick={() => setActiveRegionIdx(i)} style={miniBtn}>
                  編集
                </button>
                <button onClick={() => removeItem(i)} style={miniBtnDanger}>
                  削除
                </button>
              </div>
            ))}

          {mode === "rivers" &&
            rivers.map((r, i) => (
              <div key={i} style={row(i === activeRiverIdx)}>
                <input
                  value={r.name}
                  onChange={(e) =>
                    setRivers((prev) =>
                      prev.map((x, idx) =>
                        idx === i ? { ...x, name: e.target.value } : x
                      )
                    )
                  }
                  style={input}
                />
                <button onClick={() => setActiveRiverIdx(i)} style={miniBtn}>
                  編集
                </button>
                <button onClick={() => removeItem(i)} style={miniBtnDanger}>
                  削除
                </button>

                {i === activeRiverIdx && (
                  <div
                    style={{
                      gridColumn: "1 / span 3",
                      display: "grid",
                      gridTemplateColumns: "1fr 1fr 1fr",
                      gap: 8,
                      marginTop: 6,
                    }}
                  >
                    <label style={smallLabel}>
                      色
                      <input
                        type="color"
                        value={r.stroke}
                        onChange={(e) =>
                          setRivers((prev) =>
                            prev.map((x, idx) =>
                              idx === i ? { ...x, stroke: e.target.value } : x
                            )
                          )
                        }
                        style={{
                          width: "100%",
                          height: 32,
                          padding: 0,
                          border: "1px solid #e5e7eb",
                          borderRadius: 6,
                        }}
                      />
                    </label>
                    <label style={smallLabel}>
                      太さ
                      <input
                        type="number"
                        min={1}
                        max={40}
                        value={r.width}
                        onChange={(e) =>
                          setRivers((prev) =>
                            prev.map((x, idx) =>
                              idx === i
                                ? { ...x, width: Number(e.target.value) }
                                : x
                            )
                          )
                        }
                        style={numInput}
                      />
                    </label>
                    <label style={smallLabel}>
                      透明度
                      <input
                        type="number"
                        min={0}
                        max={1}
                        step={0.05}
                        value={r.opacity}
                        onChange={(e) =>
                          setRivers((prev) =>
                            prev.map((x, idx) =>
                              idx === i
                                ? { ...x, opacity: Number(e.target.value) }
                                : x
                            )
                          )
                        }
                        style={numInput}
                      />
                    </label>
                    <label style={{ ...smallLabel, gridColumn: "1 / span 1" }}>
                      滑らかにする
                      <input
                        type="checkbox"
                        checked={!!r.smooth}
                        onChange={(e) =>
                          setRivers((prev) =>
                            prev.map((x, idx) =>
                              idx === i ? { ...x, smooth: e.target.checked } : x
                            )
                          )
                        }
                      />
                    </label>
                    <label style={{ ...smallLabel, gridColumn: "2 / span 2" }}>
                      スムージング（tension）
                      <input
                        type="range"
                        min={0}
                        max={1}
                        step={0.05}
                        value={r.tension ?? 0.5}
                        onChange={(e) =>
                          setRivers((prev) =>
                            prev.map((x, idx) =>
                              idx === i
                                ? { ...x, tension: Number(e.target.value) }
                                : x
                            )
                          )
                        }
                      />
                    </label>
                  </div>
                )}
              </div>
            ))}

          {mode === "cities" &&
            cities.map((c, i) => (
              <div key={i} style={row(i === activeCityIdx)}>
                <input
                  value={c.name}
                  onChange={(e) =>
                    setCities((prev) =>
                      prev.map((x, idx) =>
                        idx === i ? { ...x, name: e.target.value } : x
                      )
                    )
                  }
                  style={input}
                />
                <button onClick={() => setActiveCityIdx(i)} style={miniBtn}>
                  編集
                </button>
                <button onClick={() => removeItem(i)} style={miniBtnDanger}>
                  削除
                </button>

                {i === activeCityIdx && (
                  <div
                    style={{
                      gridColumn: "1 / span 3",
                      display: "grid",
                      gridTemplateColumns: "1fr 1fr 1fr",
                      gap: 8,
                      marginTop: 6,
                    }}
                  >
                    <label style={smallLabel}>
                      色
                      <input
                        type="color"
                        value={c.color}
                        onChange={(e) =>
                          setCities((prev) =>
                            prev.map((x, idx) =>
                              idx === i ? { ...x, color: e.target.value } : x
                            )
                          )
                        }
                        style={{
                          width: "100%",
                          height: 32,
                          padding: 0,
                          border: "1px solid #e5e7eb",
                          borderRadius: 6,
                        }}
                      />
                    </label>
                    <label style={smallLabel}>
                      サイズ
                      <input
                        type="number"
                        min={3}
                        max={20}
                        value={c.size}
                        onChange={(e) =>
                          setCities((prev) =>
                            prev.map((x, idx) =>
                              idx === i
                                ? { ...x, size: Number(e.target.value) }
                                : x
                            )
                          )
                        }
                        style={numInput}
                      />
                    </label>
                    <div />
                    <div
                      style={{
                        gridColumn: "1 / span 3",
                        fontSize: 12,
                        color: "#666",
                      }}
                    >
                      位置はキャンバス上でドラッグして動かせます（クリック追加も可）
                    </div>
                  </div>
                )}
              </div>
            ))}

          <div style={{ marginTop: 8, fontSize: 12, color: "#666" }}>
            操作: クリックで点追加 / 点ドラッグで移動 / Backspaceで1点戻る
          </div>
        </div>

        {/* 右：キャンバス */}
        <div
          style={{
            flex: 1,
            background: "#fff",
            border: "1px solid #eee",
            borderRadius: 10,
            position: "relative",
            overflow: "auto",
          }}
        >
          <div style={{ width: `${(VB.w * zoom) / 100}px`, minWidth: 420 }}>
            <svg
              ref={svgRef}
              viewBox={`0 0 ${VB.w} ${VB.h}`}
              style={{
                width: "100%",
                height: "auto",
                display: "block",
                cursor: "crosshair",
              }}
              onMouseMove={onMouseMove}
              onMouseUp={onMouseUp}
              onMouseLeave={onMouseUp}
              onClick={addPoint}
            >
              {/* 背景画像 */}
              {imgUrl && (
                <image
                  href={imgUrl}
                  x="0"
                  y="0"
                  width={VB.w}
                  height={VB.h}
                  opacity={imgOpacity / 100}
                  preserveAspectRatio="none"
                />
              )}

              {/* グリッド */}
              {grid}

              {/* 川（下層） */}
              {rivers.map((r, idx) => {
                const d = r.smooth
                  ? catmullRomToBezierPath(r.points, r.tension ?? 0.5)
                  : "";
                return (
                  <g key={`river-${idx}`}>
                    {r.smooth ? (
                      <path
                        d={d}
                        fill="none"
                        stroke={r.stroke}
                        strokeWidth={r.width}
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        opacity={r.opacity}
                      />
                    ) : (
                      <polyline
                        points={toPolyString(r.points)}
                        fill="none"
                        stroke={r.stroke}
                        strokeWidth={r.width}
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        opacity={r.opacity}
                      />
                    )}
                    {mode === "rivers" &&
                      idx === activeRiverIdx &&
                      r.points.map(([x, y], j) => (
                        <circle
                          key={j}
                          cx={x}
                          cy={y}
                          r={5}
                          fill="#111827"
                          stroke="#fff"
                          strokeWidth={1.5}
                          style={{ cursor: "grab" }}
                          onMouseDown={(e) => onHandleDown(j, e)}
                        />
                      ))}
                    {r.points.length > 0 && (
                      <text
                        x={r.points[Math.floor(r.points.length / 2)][0]}
                        y={r.points[Math.floor(r.points.length / 2)][1] - 8}
                        textAnchor="middle"
                        fontSize="11"
                        fill="#0f172a"
                        fontWeight="700"
                      >
                        {r.name}
                      </text>
                    )}
                  </g>
                );
              })}

              {/* 地域（中層） */}
              {regions.map((r, idx) => (
                <g key={`region-${idx}`}>
                  <polygon
                    points={toPolyString(r.points)}
                    fill={
                      idx === activeRegionIdx && mode === "regions"
                        ? "#4ade80aa"
                        : "#60a5fa66"
                    }
                    stroke={
                      idx === activeRegionIdx && mode === "regions"
                        ? "#15803d"
                        : "#1d4ed8"
                    }
                    strokeWidth={2}
                  />
                  {mode === "regions" &&
                    idx === activeRegionIdx &&
                    r.points.map(([x, y], j) => (
                      <circle
                        key={j}
                        cx={x}
                        cy={y}
                        r={5}
                        fill="#111827"
                        stroke="#fff"
                        strokeWidth={1.5}
                        style={{ cursor: "grab" }}
                        onMouseDown={(e) => onHandleDown(j, e)}
                      />
                    ))}
                  {r.points.length > 0 && (
                    <text
                      x={
                        r.points.reduce((s, [x]) => s + x, 0) / r.points.length
                      }
                      y={
                        r.points.reduce((s, [, y]) => s + y, 0) /
                        r.points.length
                      }
                      textAnchor="middle"
                      fontSize="12"
                      fill="#111827"
                      fontWeight="700"
                    >
                      {r.name}
                    </text>
                  )}
                </g>
              ))}

              {/* 街（最上層） */}
              {cities.map((c, idx) => (
                <g key={`city-${idx}`}>
                  <circle
                    cx={c.x}
                    cy={c.y}
                    r={c.size}
                    fill={c.color}
                    stroke="#fff"
                    strokeWidth="1.5"
                    style={{
                      cursor:
                        mode === "cities" && idx === activeCityIdx
                          ? "grab"
                          : "default",
                    }}
                    onMouseDown={(e) => {
                      if (mode === "cities") {
                        setActiveCityIdx(idx);
                        setDragIdx(idx);
                        e.stopPropagation();
                      }
                    }}
                  />
                  <text
                    x={c.x + c.size + 4}
                    y={c.y - (c.size + 2)}
                    fontSize="12"
                    fill="#111827"
                    fontWeight="700"
                  >
                    {c.name}
                  </text>
                </g>
              ))}
            </svg>
          </div>
        </div>
      </div>
    </div>
  );
}

/* --- styles --- */
const btn = {
  background: "#fff",
  border: "1px solid #e5e7eb",
  padding: "6px 10px",
  borderRadius: 8,
  cursor: "pointer",
};
const btnStrong = {
  background: "#111827",
  color: "#fff",
  border: "1px solid #111827",
  padding: "6px 12px",
  borderRadius: 8,
  cursor: "pointer",
};
const miniBtn = {
  background: "#fff",
  border: "1px solid #e5e7eb",
  padding: "4px 8px",
  borderRadius: 6,
  cursor: "pointer",
  fontSize: 12,
};
const miniBtnDanger = { ...miniBtn, borderColor: "#fecaca", color: "#991b1b" };
const segBtn = {
  border: "1px solid transparent",
  padding: "6px 12px",
  borderRadius: 999,
  cursor: "pointer",
};
const row = (active) => ({
  display: "grid",
  gridTemplateColumns: "1fr auto auto",
  gap: 6,
  alignItems: "center",
  padding: "6px 8px",
  borderRadius: 8,
  marginBottom: 6,
  background: active ? "#f3f4f6" : "transparent",
  border: active ? "1px solid #e5e7eb" : "1px solid transparent",
});
const input = {
  border: "1px solid #e5e7eb",
  borderRadius: 6,
  padding: "6px 8px",
};
const smallLabel = { fontSize: 12, color: "#374151", display: "grid", gap: 4 };
const numInput = { ...input, appearance: "textfield" };
